package edu.wsu.dase.controller;

import java.util.HashMap;
import java.util.HashSet;
import java.util.TreeMap;
import java.util.Set;
import java.util.SortedMap;

import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.dataflow.qual.SideEffectFree;
import org.protege.editor.owl.ui.prefix.PrefixUtilities;
import org.semanticweb.owlapi.model.OWLAnnotation;
import org.semanticweb.owlapi.model.OWLAnnotationProperty;
import org.semanticweb.owlapi.model.OWLAxiom;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyManager;
import org.semanticweb.owlapi.model.PrefixManager;
import org.semanticweb.owlapi.util.DefaultPrefixManager;

import edu.wsu.dase.model.Constants;
import edu.wsu.dase.model.RuleModel;
import edu.wsu.dase.model.RuleTableModel;
import edu.wsu.dase.view.RuleEditorPanel;
import edu.wsu.dase.view.RuleTablePanel;

public class Engine {

	private OWLOntology activeOntology;
	private TreeMap<String, Set<OWLAxiom>> axiomsWithID;
	private TreeMap<String, RuleModel> rulesWithID;
	private PrefixManager prefixManager;
	private OWLOntologyManager owlOntologyManager;
	private OWLDataFactory owlDataFactory;
	private OWLAnnotationProperty fixedAnnotationProperty;
	
	private RuleTableModel ruleTableModel;
	
	private RuleTablePanel ruleTablePanel;
	
	private RuleEditorPanel ruleEditorPanel;

	/**
	 * @return the ruleEditorPanel
	 */
	public RuleEditorPanel getRuleEditorPanel() {
		return ruleEditorPanel;
	}

	/**
	 * @param ruleEditorPanel the ruleEditorPanel to set
	 */
	public void setRuleEditorPanel(RuleEditorPanel ruleEditorPanel) {
		this.ruleEditorPanel = ruleEditorPanel;
	}

	/**
	 * @return the ruleTablePanel
	 */
	public RuleTablePanel getRuleTablePanel() {
		return ruleTablePanel;
	}

	/**
	 * @param ruleTablePanel the ruleTablePanel to set
	 */
	public void setRuleTablePanel(RuleTablePanel ruleTablePanel) {
		this.ruleTablePanel = ruleTablePanel;
	}

	/**
	 * @return the ruleTableModel
	 */
	public RuleTableModel getRuleTableModel() {
		return ruleTableModel;
	}

	/**
	 * @param ruleTableModel the ruleTableModel to set
	 */
	public void setRuleTableModel(RuleTableModel ruleTableModel) {
		this.ruleTableModel = ruleTableModel;
	}

	public Engine(OWLOntology activeOntology) {
		this.activeOntology = activeOntology;
		this.owlOntologyManager = this.activeOntology.getOWLOntologyManager();
		this.owlDataFactory = this.owlOntologyManager.getOWLDataFactory();

		this.prefixManager = PrefixUtilities.getPrefixOWLOntologyFormat(activeOntology);
		fixedAnnotationProperty = activeOntology.getOWLOntologyManager().getOWLDataFactory()
				.getOWLAnnotationProperty(Constants.FIXED_ANNOTATION_NAME, prefixManager);

		initializeDataStructure();

		reloadRulesAndAxiomsFromOntology();

	}

	private void initializeDataStructure() {
		rulesWithID = new TreeMap<String, RuleModel>();
		axiomsWithID = new TreeMap<String, Set<OWLAxiom>>();
	}

	public TreeMap<String, RuleModel> getRules() {

		return this.rulesWithID;
	}

	public RuleModel getRulebyID(String ruleName) {
		if (rulesWithID.containsKey(ruleName)) {
			return rulesWithID.get(ruleName);
		}
		return null;
	}

	public Set<OWLAxiom> getAxiomsbyID(String ruleName) {

		if (axiomsWithID.containsKey(ruleName)) {
			return axiomsWithID.get(ruleName);
		}
		return null;
	}

	public void addARulesWithID(String ruleName, RuleModel rule) {
		rulesWithID.put(ruleName, rule);
	}

	public void addAxiomsWithID(String ruleName, Set<OWLAxiom> axiomSet) {
		axiomsWithID.put(ruleName, axiomSet);
	}

	/**
	 * Delete Rule from the table.
	 * 
	 * 
	 * has to be sure from Adila.
	 * 
	 * Possible option 1. also remove corresponding
	 * axioms from ontology or 2. only remove corresponding annotations from
	 * those axioms
	 * 
	 * Current implementation remove corresponding axioms from ontology
	 * 
	 * @param ruleName
	 */
	public void deleteRule(String ruleName) {
		if (rulesWithID.containsKey(ruleName)) {
			rulesWithID.remove(ruleName);
		}

		if (axiomsWithID.containsKey(ruleName)) {
			owlOntologyManager.removeAxioms(activeOntology, axiomsWithID.get(ruleName));
			axiomsWithID.remove(ruleName);
		}
	}

	public void OntologyChanged() {
		// reloadRulesAndAxiomsFromOntology();
	}

	public boolean checkDuplicateRuleName(String RuleName) {
		if (rulesWithID.containsKey(RuleName))
			return true;
		else
			return false;
	}

	public boolean checkDuplicateRuleText(String RuleText) {
		if (rulesWithID.containsValue(RuleText))
			return true;
		else
			return false;
	}

	public String getAutogeneratedNextRuleName() {
		int size = rulesWithID.size() + 1;
		return "R" + size;
	}

	private void reloadRulesAndAxiomsFromOntology() {

		// JPopupMenu
		if (rulesWithID != null)
			rulesWithID.clear();
		if (axiomsWithID != null)
			axiomsWithID.clear();

		Set<OWLAxiom> tmpAxioms = new HashSet<OWLAxiom>();
		String tmpRuleID = "";
		int i = 0;

		/**
		 * when converting rule to owl, single rule can generate multiple
		 * axioms. That means multiple axioms need to be binded for a single
		 * rule-id
		 */
		for (OWLAxiom ax : activeOntology.getAxioms()) {
			for (OWLAnnotation ann : ax.getAnnotations()) {
				for (OWLAnnotationProperty anp : ann.getAnnotationPropertiesInSignature()) {
					if (anp.equals(fixedAnnotationProperty)) {
						System.out.println("\n\naxiom before parse: " + ax.toString() + "\n\n");
						String val = ann.getValue().asLiteral().get().getLiteral();
						String[] values = val.split("___", 3);

						if (values.length == 3) {
							String ruleID = values[0];
							String ruleText = values[1];
							String ruleComment = values[2];
							if (ruleID.length() > 0 && ruleText.length() > 0) {

								// add to rulewith ID
								rulesWithID.put(ruleID, new RuleModel(ruleID, ruleText, ruleComment));

								System.out.println("axiomsWithID length before: " + axiomsWithID.size());
								// add to axioms with ID
								System.out.println("equal or not:  " + tmpRuleID + "  " + ruleID);

								if (axiomsWithID.containsKey(ruleID)) {
									axiomsWithID.get(ruleID).add(ax);
								} else {
									tmpAxioms = new HashSet<OWLAxiom>();
									tmpAxioms.add(ax);
									axiomsWithID.put(ruleID, tmpAxioms);
								}

								// if (tmpRuleID != ruleID) {
								// tmpAxioms.clear();
								// }
								//
								// tmpRuleID = ruleID;
								// tmpAxioms.add(ax);
								// System.out.println("tmpAxioms Size: "+
								// tmpAxioms.size());
								// axiomsWithID.put(ruleID, tmpAxioms);

								// if (i == 0) { // initial case
								// tmpAxioms.add(ax);
								// axiomsWithID.put(values[0], tmpAxioms);
								// tmpRuleID = values[0];
								// i++;
								// } else { // latter case
								// if (tmpRuleID == values[0]) {
								// /**
								// * this rule-id has this axiom and may
								// * contain more axiom
								// */
								// tmpAxioms.add(ax);
								// axiomsWithID.put(values[0], tmpAxioms);
								// } else {
								// /**
								// * now this rule-id is saturated and
								// * tmpAxioms is filled with all Axioms
								// * binded to this rule-id
								// */
								//
								// axiomsWithID.put(values[0], tmpAxioms);
								//
								// tmpAxioms.clear();
								// tmpAxioms.add(ax);
								// tmpRuleID = values[0];
								// }
								// }
								System.out.println("axiomsWithID length after: " + axiomsWithID.size());
							}
						} else {
							System.out.println("Annotation doesn't have 3 parts");
						}
					}
				}
			}
		}
	}

}
